// This is an experimental feature used to generate Rust bindings from Candid.
// THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE TO AVOID DATA LOSS.
#![allow(dead_code, unused_imports, non_snake_case)]
use candid::{self, CandidType, Decode, Deserialize, Encode, Principal};

#[derive(CandidType, Deserialize)]
pub enum Error {
    CanisterError(String),
    InvalidCanister,
}

#[derive(CandidType, Deserialize)]
pub enum Result_ {
    Ok(Vec<Vec<String>>),
    Err(Error),
}

pub struct IcRusqliteBackendCanister {
    pub canister_id: Principal,
    pub caller: super::Caller,
}

impl IcRusqliteBackendCanister {
    pub fn add(&self, arg0: String, arg1: String, arg2: u32) -> super::CallBuilder<()> {
        let args = Encode!(&arg0, &arg1, &arg2);
        self.caller
            .call(self.canister_id, super::CallMode::Update, "add", args)
    }
    pub fn list(&self) -> super::CallBuilder<Vec<(u64, String, String, u32)>> {
        let args = Encode!();
        self.caller
            .call(self.canister_id, super::CallMode::Update, "list", args)
    }
    pub fn query(&self, arg0: String) -> super::CallBuilder<Result_> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Update, "query", args)
    }
}

pub fn new(caller: &super::Caller, canister_id: Principal) -> IcRusqliteBackendCanister {
    IcRusqliteBackendCanister {
        canister_id,
        caller: caller.clone(),
    }
}

pub fn deploy(deployer: &super::Deployer) -> super::DeployBuilder<IcRusqliteBackendCanister> {
    let args = Encode!();
    let result = deployer.deploy(args, new);
    let result = if let Some(id) = canister_id() {
        result.with_canister_id(id)
    } else {
        result
    };
    if let Some(wasm) = wasm() {
        result.with_wasm(wasm)
    } else {
        result
    }
}
pub fn canister_id() -> Option<Principal> {
    None
}

pub fn wasm() -> Option<Vec<u8>> {
    let mut path = std::path::PathBuf::new();
    path.push("../.dfx/local/canisters/ic-rusqlite-backend/ic-rusqlite-backend.wasm.gz");
    let wasm = std::fs::read(path.as_path())
        .unwrap_or_else(|_| panic!("wasm binary not found: {:?}", path));
    Some(wasm)
}
